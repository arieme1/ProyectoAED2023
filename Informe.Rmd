---
title: "Informe"
author: "Mar Riveiro Cabado"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introducción

# Instalación y carga de librerías necesarias

```{r}
rm(list=ls())
library(pacman)
packages = c("knitr", "ggplot2","tidyr","dplyr","readr","GGally", "mice", "robustbase", "leaflet")
pacman::p_load(char=packages)
```

# Conjunto de datos


```{r}
estaciones<-read_delim("./data/Maestro_Climatologico_2022.csv", 
    delim = ";", escape_double = FALSE, trim_ws = TRUE,show_col_types = FALSE)

agregar_separador <- function(numero, posicion) {
  # Convertir el número a cadena de caracteres
  numero_str <- as.character(numero)
  
  # Insertar el separador en la posición deseada
  numero_formateado <- paste0(
    substr(numero_str, 1, posicion),
    ".",
    substr(numero_str,posicion + 1, nchar(numero_str))
  )
  
  # Devolver el resultado como número
  return(as.numeric(numero_formateado))
}

estaciones$LATITUD <- agregar_separador(estaciones$LATITUD, 2)
estaciones$LONGITUD <- agregar_separador(estaciones$LONGITUD, 1)

estaciones$LONGITUD<-estaciones$LONGITUD*(-1)


estaciones$LONGITUD[estaciones$PROVINCIA %in% c("TARRAGONA", "BARCELONA")] <- -estaciones$LONGITUD[estaciones$PROVINCIA %in% c("TARRAGONA", "BARCELONA")]

estaciones$LONGITUD[estaciones$PROVINCIA %in% c("LAS PALMAS", "SANTA CRUZ DE TENERIFE")] <- 10*estaciones$LONGITUD[estaciones$PROVINCIA %in% c("LAS PALMAS", "SANTA CRUZ DE TENERIFE")]
```
Tras un primer visionado de los datos vemos que debido a la codificación existen caracteres erróneos en el csv desde el que cargamos las coordenadas de los municipios. Posteriormente, a la hora de elaborar un mapa interactivo, vemos que las coordenadas precisan una corrección de formato (separador decimal tras los primeros o segundos dígitos según sean longitud o latitud, respectivamente). Hacemos también unas correcciones de las coordenadas de Islas Canarias que aparecen desplazadas hacia la derecha con respecto a la localización correcta.

```{r}
carpeta_base<-"./data/Variables/"

años<-2016:2022
lista_dataframes <- list()

for (año in años){
  
  ruta_carpeta<-file.path(carpeta_base, as.character(año))
  archivos_climaticos <- list.files(ruta_carpeta,pattern = ".*.csv")
  
  df_año<-data.frame(Indicativo = character(0), 
                     Meses = character(0), Valores= numeric(0))

  for (archivo in archivos_climaticos) {
    
    ruta_completa_archivo<-file.path(ruta_carpeta,archivo)
    variable <-read_delim(ruta_completa_archivo, delim = ";",
                          escape_double = FALSE, trim_ws=TRUE,
                          show_col_types=FALSE)
    prefijo <- substr(archivo, 1, nchar(archivo) - 9)
  
    df_variable <- variable %>%
        pivot_longer(col = -c(Indicativo), names_to = "Meses", 
                     values_to = prefijo) 
    
      if (archivo == archivos_climaticos[1]) {
          
        df_año <- df_variable
        
       } else {
         
        df_año <- left_join(df_año,df_variable,
                            by=join_by("Indicativo","Meses"))
       }
    
  }
    lista_dataframes[[as.character(año)]] <- df_año
    assign(paste0("df_", año), df_año, envir = .GlobalEnv)
    carpeta<-"./data/"
    nombre_archivo <- file.path(carpeta, paste0("dataset_",año,".csv"))
    write.csv(df_año, nombre_archivo, row.names = FALSE)
}

```



Las variables que hemos tenido en consideración de todas las que aparecen en los repositorios de AEMET son:

  * HR -> humedad relativa mensual/anual (%)
  * INSO -> Media mensual/anual de la insolación diaria (horas)
  * P_MES -> Precipitación total mensual/anual (mm)
  * TM_MAX -> Temperatura media mensual/anual de las máximas (°C)
  * TM_MES -> Temperatura media mensual/anual (°C)
  * TM_MIN -> Temperatura media mensual/anual de las mínimas (°C)

De los cuáles analizamos las más representativas.

# Exploración Inicial de los datos

## Comprobación de datos faltantes e imputación

```{r}
faltan_2016<- colMeans(is.na(df_2016)) * 100

data_filtered <- df_2016 %>% filter(Meses != "anual") #filtro el dataset quitando los años

imputed_data_filtered <- mice(data_filtered, m = 5) #hago la imputación de datos con mice

imputed_data_2016 <- complete(imputed_data_filtered, action = 1) #introduzco los datos

filtered_rows <- df_2016 %>% filter(Meses == "anual") #tomo el dataset que solo contiene los "anual"

#ahora obtengo los valores anuales por indicativo para cada variable
columnas <- c("HR", "INSO","TM_MAX","TM_MES","TM_MIN","W_MED")
columnas2 <- c("P_MES")
columnas_F <- c("HR", "INSO","P_MES","TM_MAX","TM_MES","TM_MIN","W_MED")

#dataframe con los promedios anuales por indicativo
result <- imputed_data_2016 %>%
  group_by(Indicativo) %>%
  summarise(across(all_of(columnas), mean))

#dataframe con la suma anual de precipitaciones
result2 <-imputed_data_2016 %>%
  group_by(Indicativo)%>%
  summarise(across(all_of("P_MES"), sum))

#los uno y los ordeno conforme al original
df_2016_anual <- mutate(result, result2)
df_2016_anual <-df_2016_anual[,c("Indicativo","HR", "INSO","P_MES","TM_MAX","TM_MES","TM_MIN","W_MED")]

d_prueba<- imputed_data_2016 %>% group_by(Meses)

```

A partir de los dataset para cada año obtenidos de los dataset para cada variable climatológica, queremos costruir un nuevo dataset en el que además de recopilar dicha información, imputemos los valores correspondientes allá donde tenemos NA's. Esto lo haremos para cada año mediante un bucle, por el cuál separaremos los valores anuales de las variables (suma de los meses en el caso de las precipitaciones y promedio en el caso del resto de variables) del resto del dataset y crearemos un nuevo dataset para cada año donde se almacenen los valores anuales para cada estación meteorológica y cada variable. 

```{r}
#ANUAL
estaciones <- estaciones %>%
  rename(Indicativo = INDICATIVO)
Indicativos_maestro <- unique(unlist(estaciones[,"Indicativo"]))
años<-2016:2022
columnas <- c("HR", "INSO","TM_MAX","TM_MES","TM_MIN","W_MED")
columnas2 <- c("P_MES")
dataframes_anuales <- list()
dataframes_mensuales <- list()
i <- 2016

for (df in lista_dataframes){
  Indicativos_df <- unique(unlist(df[,"Indicativo"]))
  I_comunes <- intersect(Indicativos_df, Indicativos_maestro)
  
  Localizame <- estaciones[,c("Indicativo","PROVINCIA", "LONGITUD", "LATITUD", "MUNICIPIO")]
  Localizame <- Localizame%>%subset(Indicativo %in% I_comunes)

  data_filtered <- df %>% filter(Meses != "anual")%>%subset(Indicativo %in% I_comunes) 

  imputed_data_filtered <- mice(data_filtered, m = 5) 
  imputed_data <- complete(imputed_data_filtered, action = 1) 
#hago la imputación de datos con mice e introduzco los datos

  filtered_rows <- df %>% filter(Meses == "anual")%>%subset(Indicativo %in% I_comunes) 

  result <- imputed_data %>%group_by(Indicativo) %>%summarise(across(all_of(columnas), mean))

  result2 <-imputed_data %>%group_by(Indicativo)%>%summarise(across(all_of("P_MES"), sum))

  df_anual <- mutate(result, result2)
  df_anual<-df_anual[,c("Indicativo","HR","INSO","P_MES","TM_MAX","TM_MES","TM_MIN","W_MED")]
  df_anual <- merge(df_anual, Localizame, by = "Indicativo")
  nombre_df_a <- paste0("df_anual", i)
  dataframes_anuales[[nombre_df_a]] <- df_anual
  
  
  df_mensual <- merge(imputed_data, Localizame, by = "Indicativo")
  nombre_df_m <-paste0("df_mensual", i)
  dataframes_mensuales[[nombre_df_m]] <- df_mensual
  i<-i+1
}
list2env(dataframes_mensuales, envir = .GlobalEnv)
list2env(dataframes_anuales, envir = .GlobalEnv)
```

La imputación de datos se lleva a cabo mediante la librería $mice$, concretamente el método empleado por la librería para añadir los valores más coherentes es mediante la mediana de los datos de las variables para cada indicativo:
```{r}
summary(imputed_data_filtered)
```


Una vez imputados los datos para los dataset que contienen la información mensual, adherimos las columnas de coordenadas, provincia y municipio para ubicar dichas estaciones espacialmente.



## Visualización de los datos

```{r}
grupo <- imputed_data_2016 %>% group_by(Indicativo, Meses)

ggplot(grupo, aes(x = grupo$Meses, y = grupo$P_MES , fill = grupo$Indicativo)) +
  geom_bar(stat = "identity") +
  labs(x = "Mes", y = "Promedio de Valor", title = "Precipitaciones") + theme(axis.text.x = element_text(angle = 90, hjust = 1))+
  theme_minimal()
```


## Comprobación de outliers

```{r}
grupo <- df_mensual2022 %>% group_by(Indicativo, Meses)

grupo$Meses <- factor(grupo$Meses, levels = c("enero", "febrero", "marzo", "abril", "mayo", "junio", "julio", "agosto" ,"septiembre", "octubre", "noviembre", "diciembre"))

# ggplot(grupo, aes(x = grupo$Meses, y = grupo$P_MES , fill = grupo$Indicativo)) +
#   geom_bar(stat = "identity") +
#   labs(x = "Mes", y = "Promedio de Valor", title = "Precipitaciones") + theme(axis.text.x = element_text(angle = 90, hjust = 1))+
#   theme_minimal()

#Para el calculo de outliers se hizo uso de la regla MADM
outliers <- which(abs(grupo$W_MED- median(grupo$W_MED)) > 3*mad(grupo$W_MED))

for (i in names(grupo)) {
  if (is.numeric(grupo[[i]])) {
    outliers <- boxplot.stats(grupo[[i]])$out
  }
  
print(outliers)
}

grupo %>%
  ggplot(aes(x = Meses, y = HR)) + 
   geom_boxplot() 
  

grupo %>%
  ggplot(aes(x = Meses, y = INSO)) + 
   geom_boxplot() 

grupo %>%
  ggplot(aes(x = Meses, y = P_MES)) + 
   geom_boxplot() 

grupo %>%
  ggplot(aes(x = Meses, y = TM_MAX)) + 
   geom_boxplot() 

grupo %>%
  ggplot(aes(x = Meses, y = TM_MES)) + 
   geom_boxplot() 

grupo %>%
  ggplot(aes(x = Meses, y = TM_MIN)) + 
   geom_boxplot() 
grupo %>%
  ggplot(aes(x = Meses, y = W_MED)) + 
   geom_boxplot() 
```

## Estadísticos

```{r}
d_prueba <- df_mensual2022%>%group_by(Meses)
estadisticos <- d_prueba %>%
  summarise(across(where(is.numeric), 
                   list(mean = ~mean(., na.rm = TRUE), 
                        sd = ~sd(., na.rm = TRUE), 
                        median = ~median(., na.rm = TRUE),
                        iqr = ~IQR(., na.rm = TRUE))))

```

*Mediana Absoluta de la Desviación*

```{r}
columnas_variables<- d_prueba[,!(names(d_prueba) %in% c("Indicativo", "Meses", "PROVINCIA", "LONGITUD", "LATITUD", "MUNICIPIO"))]
mad_<- sapply(columnas_variables, mad)
print(mad_)
```

# Análisis Univariado

El análisis univariante que podemos realizar para nuestro conjunto de datos está limitado a las variables numéricas, ya que no contamos con variables categóricas. El estudio más represenativo para nuestros datos consiste en estudiar la evolución de las precipitaciones y las temperaturas mensuales para los años de los que tenemos información, desde 2017 hasta 2022. Hemos rechazado incluir los datos de 2016 por no aportar más información al análisis y así evitar saturar nuestros gráficos.

```{r}
#COMPLETO 2016:2022
library(ggthemes)

lluvias_2022 <- df_mensual2022 %>% group_by(Meses)%>% summarise(prom_HR = mean(HR))%>%mutate(Año = 2022)
lluvias_2021 <- df_mensual2021 %>% group_by(Meses)%>% summarise(prom_HR = mean(HR))%>%mutate(Año = 2021)
lluvias_2020 <- df_mensual2020 %>% group_by(Meses)%>% summarise(prom_HR = mean(HR))%>%mutate(Año = 2020)
lluvias_2019 <- df_mensual2019 %>% group_by(Meses)%>% summarise(prom_HR = mean(HR))%>%mutate(Año = 2019)
lluvias_2018 <- df_mensual2018 %>% group_by(Meses)%>% summarise(prom_HR = mean(HR))%>%mutate(Año = 2018)
lluvias_2017 <- df_mensual2017 %>% group_by(Meses)%>% summarise(prom_HR = mean(HR))%>%mutate(Año = 2017)


lluvias <- bind_rows(lluvias_2022,lluvias_2021, lluvias_2020,lluvias_2019)
lluvias$Meses <- factor(lluvias$Meses, levels = c("enero", "febrero", "marzo", "abril", "mayo", "junio", "julio", "agosto" ,"septiembre", "octubre", "noviembre", "diciembre"))

# Crea el gráfico de línea

precipitaciones = ggplot(lluvias, aes(x = Meses, y = prom_HR, group = Año))+geom_line(aes(linetype =  factor(Año),color=factor(Año)),size = 1.3, alpha = 0.7) + labs(title = "Promedio mensual de precipitaciones", subtitle = "España 2022", x = "Meses", y = "Precipitaciones (mm)")+ theme_fivethirtyeight() + theme(axis.text.x = element_text(angle = 45, hjust = 1)) + theme(legend.title=element_blank())
precipitaciones

```

Puede apreciarse una bajada considerable de las precipitaciones en España en 2022 con respecto a los dos últimos años anteriores, equiparándose a las precipitaciones del año 2019. Procedemos análogamente con las temperaturas máxima y media.

```{r}
tmax_2022 <- df_mensual2022 %>% group_by(Meses)%>%summarise(prom_tmax = mean(TM_MAX))%>%mutate(Año = 2022)
tmax_2021 <- df_mensual2021 %>% group_by(Meses)%>%summarise(prom_tmax = mean(TM_MAX))%>%mutate(Año = 2021)
tmax_2020 <- df_mensual2020 %>% group_by(Meses)%>%summarise(prom_tmax = mean(TM_MAX))%>%mutate(Año = 2020)
tmax_2019 <- df_mensual2019 %>% group_by(Meses)%>%summarise(prom_tmax = mean(TM_MAX))%>%mutate(Año = 2019)
tmax_2018 <- df_mensual2018 %>% group_by(Meses)%>%summarise(prom_tmax = mean(TM_MAX))%>%mutate(Año = 2018)
tmax_2017 <- df_mensual2017 %>% group_by(Meses)%>%summarise(prom_tmax = mean(TM_MAX))%>%mutate(Año = 2017)

tmaximas <- bind_rows(tmax_2022, tmax_2021, tmax_2020,tmax_2019)
tmaximas$Meses <- factor(tmaximas$Meses, levels = c("enero", "febrero", "marzo", "abril", "mayo", "junio", "julio", "agosto" ,"septiembre", "octubre", "noviembre", "diciembre"))

maximas = ggplot(tmaximas, aes(x = Meses, y = prom_tmax, group = Año))+geom_line(aes(linetype =  factor(Año),color=factor(Año)),size = 1, alpha = 0.7) + labs(title = "Temperaturas máximas", subtitle = "España 2022", x = "Meses", y = "Temperatura (ºC)")+ theme_fivethirtyeight() + theme(axis.text.x = element_text(angle = 45, hjust = 1)) + theme(legend.title=element_blank()) + scale_color_brewer(palette = "PuOr")
maximas
```

```{r}
tmed_2022 <- df_mensual2022 %>% group_by(Meses)%>%summarise(prom_tmed = mean(TM_MES))%>%mutate(Año = 2022)
tmed_2021 <- df_mensual2021 %>% group_by(Meses)%>%summarise(prom_tmed = mean(TM_MES))%>%mutate(Año = 2021)
tmed_2020 <- df_mensual2020 %>% group_by(Meses)%>%summarise(prom_tmed = mean(TM_MES))%>%mutate(Año = 2020)
tmed_2019 <- df_mensual2019 %>% group_by(Meses)%>%summarise(prom_tmed = mean(TM_MES))%>%mutate(Año = 2019)
tmed_2018 <- df_mensual2018 %>% group_by(Meses)%>%summarise(prom_tmed = mean(TM_MES))%>%mutate(Año = 2018)
tmed_2017 <- df_mensual2017 %>% group_by(Meses)%>%summarise(prom_tmed = mean(TM_MES))%>%mutate(Año = 2017)

tmed <- bind_rows(tmed_2022, tmed_2021, tmed_2020,tmed_2019)
tmed$Meses <- factor(tmed$Meses, levels = c("enero", "febrero", "marzo", "abril", "mayo", "junio", "julio", "agosto" ,"septiembre", "octubre", "noviembre", "diciembre"))

medias = ggplot(tmed, aes(x = Meses, y = prom_tmed, group = Año))+geom_line(aes(linetype =  factor(Año),color=factor(Año)),size = 1, alpha = 0.7) + labs(title = "Temperaturas medias", subtitle = "España 2022", x = "Meses", y = "Temperatura (ºC)")+ theme_fivethirtyeight() + theme(axis.text.x = element_text(angle = 45, hjust = 1)) + theme(legend.title=element_blank()) + scale_color_brewer(palette = "Set2")
medias
```

Al comparar con los resúmenes estacionales climatológicos de AEMET para 2022 [*] (referenciar) vemos que los datos que representamos se mantienen coherentes con los expuestos en los resúmenes oficiales, por lo que nos inclinamos a pensar que la imputación de los datos por parte de la librería empleada es válida.
# Análisis Bivariado

* Coeficiente de Correlación de Pearson: Mide la fuerza y dirección de una relación lineal.

```{r}
cov(columnas_variables, use = "everything",method = "pearson")
cp<-cor(columnas_variables, use = "everything",method ="pearson")
```


* Coeficiente de Correlación de Spearman: Evalúa la relación monótona entre dos variables.

```{r}
cov(columnas_variables, use = "everything",method = "spearman")
cor(columnas_variables, use = "everything",method ="spearman")
```

```{r}
library(corrplot)
corrplot(cp, method = "circle", title = "Matriz de Correlaciones")
```

```{r}
library(GGally)
ggpairs(columnas_variables)
```


# Visualización de los datos

### Mapa interactivo

En el mapa interactivo se muestran las estaciones meteorológicas donde se tomaron los datos para cada año correspondiente. Mostramos el municipio donde se ubican y algunas variables anuales de las mismas.

```{r}
mapa_espana <- leaflet() %>%
  addTiles() %>%
  setView(lng = -4, lat = 40, zoom = 6) %>% addCircles(lng = df_anual2022$LONGITUD, lat = df_anual2022$LATITUD, data = df_anual2022,radius = 5, popup = paste0(
  df_anual2022$MUNICIPIO,"<hr>",
  "T. Med (ºC):", round(df_anual2022$TM_MES,1),"<br>",
  "T. Max (ºC):", round(df_anual2022$TM_MAX,1),"<br>",
  "Precipitaciones (mm):", round(df_anual2022$P_MES),"<br>",
  "Insolación (horas):", round(df_anual2022$INSO,1)))

# Muestra el mapa
mapa_espana
```



# Conclusiones







